# Chapter 1 - 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?
## 1.1 역사의 흐름은 무엇인가?
자바 역사를 통틀어 가장 큰 변화가 자바8에서 일어났습니다. 자바 10에서는 형 추론과 관련해 약간의 변화만 일어났습니다.  
예를 들어 다음은 사과 목록을 무게순으로 정렬하는 고전적 코드입니다.  
```java
Collections.sort(inventory, new Comparator<Apple>() {
  @Override
  public int compare(Apple a1, Apple a2) {
    return Integer.compare(a1.getWeight(), a2.getWeight());
  }
});
```
Java8을 이용하면 자연어에 더 가깝게 간단한 방식으로 코드를 구현할 수 있습니다.
```java
inventory.sort(comparing(Apple::getWeight));
```
위 두 코드는 사과의 무게를 비교해서 목록에서 정렬합니다.  
  
지금까지의(Java8이전) 대부분의 자바 프로그램은 코어 중 하나만을 사용했습니다.  
나머지 코어는 유휴 idle 코어로 두거나, 운영체제나 바이러스 검사 프로그램과 프로세스 파워를 나눠서 사용했습니다.  
  
Java8이 등장하기 이전에는 나머지 코어를 활용하려면 스레드를 사용하는 것이 좋다고 누군가가 조언했을 것입니다.  
하지만 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점이 있습니다.  
자바는 이러한 `병렬 실행 환경`을 쉽게 관리하고 `에러가 덜 발생하는 방향`으로 진화하려 노력했습니다.  
  
- Java1.0 : 스레드, 락(lock), 메모리 모델  
- Java5 : 스레드 풀, 병렬 실행 컬렉션  
- Java7 : 병렬 실행에 도움을 줄 수 있는 포크/조인 프레임워크 제공   
- `Java8 : 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법!`  
  
Java8은 `간결한 코드, 멀티코어 프로세서의 쉬운 활용`이라는 두 가지 요구사항을 기반으로 합니다.  
Java8에서 제공하는 새로운 기술은 다음과 같습니다.  
- 스트림 API  
- 메서드에 코드를 전달하는 기법  
- 인터페이스의 디폴트 메서드  
  
Java8은 `병렬 연산을 지원하는 스트림`이라는 새로운 API를 제공합니다.  
데이터베이스 질의 언어(SQL)에서 고수준 언어로 원하는 동작을 표현하면, 구현(스트림 라이브러리)에서 최적의 저수준 실행  
방법을 선택하는 방식으로 동작합니다. 즉, 스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 키워드  
`synchronized`를 사용하지 않아도 됩니다.  
  
메서드에 코드를 전달하는 기법을 이용하면 새롭고 간결한 방식으로 `동작 파라미터화(behavior parameterization)`을 구현할 수 있습니다.  
메서드에 코드를 전달 (뿐만 아니라 결과를 반환하고 다른 자료구조로 전달할 수도 있음) 하는 자바 8 기법은 `함수형 프로그래밍`에서 위력을 발휘합니다.  
  
## 1.2 왜 아직도 자바는 변화하는가? 
모든 프로그래밍 언어는 장단점을 가지고 있습니다.  
자바는 처음부터 스레드와 락을 이용한 소소한 동시성을 지원했습니다.  
하드웨어 중립적인 메모리 모델 때문에 멀티코어 프로세서에서 병렬적으로 수행되는 스레드는 싱글코어에서의 동작과 달리 예기치 못한 상황을 일으킬 수 있습니다.  
  
코드를 `JVM 바이트 코드로 컴파일하는 특징`, 그리고 `모든 브라우저에서 가상 머신 코드를 지원하기` 때문에 자바는 인터넷 애플리케이션 프로그램의 주요 언어가 되었습니다.  
  
객체지향이 각광받은 두 가지 이유는 첫 번째로 `캡슐화`덕분에 C에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다는점, 두 번째는 `객체지향의 정신적인 모델`덕분에  
윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있다는 점입니다.  
이것은 **모든 것은 객체다**로 요약할 수 있습니다.  
  
프로그래머는 빅데이터(테라바이트, 즉 10의12승 바이트)라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커졌습니다.  
즉, 병렬 프로세싱을 활용해야 하는 데 지금까지의 자바로는 충분히 대응할 수 없었습니다.  
  
지금부터 소개하는 세 개의 절에서는 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념입니다.  
### 1.2.2 스트림 처리
`스트림`이란 **한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임**입니다.  
이런적으로 프로그램은 `입력 스트림`에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록합니다.  
즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있습니다.  
  
유닉스나 C의 stdin, 자바의 System.in과 같은 표준 입력에서 데이터를 읽은 다음에, 데이터를 처리하고, 결과를 유닉스와 C의 stdout, 자바의 System.out와 같은 표준 출력으로 기록합니다.  
  
`cat file1 file2 | tr"[A-Z]" "[a-z]" | sort | tail -3`  
cat : 두 파일을 연결해서 스트림을 생성합니다.  
tr : 스트림의 문자를 번역합니다.  
sort : 스트림의 행을 정렬합니다.
tail - 3 : 스트림의 마지막 3개 행을 제공합니다.  
파이프(|)를 이용해서 명령을 연결할 수 있습니다.  

이 예제는 파일의 단어를 소문자로 바꾼 다음에 사전순으로 단어를 정렬했을 때 가장 마지막에 위치한 세 단어를 출력하는 프로그램입니다.  
sort는 여러 행의 스트림을 입력으로 받아 여러 행의 스트림을 출력으로 만들어냅니다.  
유닉스에서는 여러 명령(cat, tr, sort, tail)을 `병렬`로 실행합니다. `따라서 cat이나 tr이 완료되지 않은 시점에서 sort가 행을 처리하기 시작할 수 있습니다.`  
  
Java8에서는 java.util.stream 패키지에 스트림 API가 추가되었습니다.  
**Stream<T>**는 T 형식으로 구성된 일련의 항목을 의미합니다. 우선은 스트림 API가 조립 항목처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 단순하게 생각합시다.  
  
`스트림 API의 핵심`은 기존에는 한번에 한 항목을 처리했지만 이제 Java8에서는 우리가 하려는 작업을 (SQL처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리  
할 수 있다는 것입니다. 또한 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있습니다.  
스레드라는 복잡한 작업을 사용하지 않으면서도 **공짜**로 병렬성을 얻을 수 있습니다.  

### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기
Java8에 추가된 두 번째 프로그램 개념은 `코드 일부를 API로 전달하는 기능`입니다.  
  
예를 들어 2013UK0001, 2014US0002... 등의 형식을 갖는 송장 ID가 있고 우리는 이 송장 ID를 고객 ID 또는 국가 코드순으로 정렬해야 합니다.  
sort 명령을 이용하려면 sort가 고객 ID나 국가 코드로 송장 ID를 정렬하도록 **sort에 따로 코드를 제공**해야 합니다.  
  
우선은 두 송장 ID를 비교하는 `compareUsingCustomId`메서드를 구현할 수 있습니다. 그런데 Java8 이전의 자바에서는 `메서드를 다른 메서드로 전달할 방법이 없었습니다.`  
Java8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공합니다. 즉, compareUsingCustomId 메서드를 sort의 인수로 전달하는 것입니다.  
이러한 기능을 이론적으로 **`동작 파라미터화`** 라고 부릅니다.  
  
동작 파라미터화가 왜 중요할까요?  
  
`compareUsingCustomId`를 이용해 sort의 동작을 파라미터화했던 것처럼 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문입니다.  
### 1.2.4 병렬성과 공유 가변 데이터
세 번째 프로그래밍의 개념은 `병렬성을 공짜로 얻을 수 있다`라는 말에서 시작됩니다.  
공짜로 얻는 대신, 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 합니다.  
  
스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 합니다. 그러려면 `공유된 가변 데이터(shared mutable data)`에 접근하지 않아야 합니다.  
이러한 함수를 순수(pure) 함수, 부작용 없는(side-effect-free) 함수, 상태 없는(Stateless) 함수라 부릅니다.  
  
물론 기존처럼 synchronized를 사용할 수 있습니다.(일반적으로 synchronized는 시스템 성능에 악영향을 미칩니다.)    
## 1.3 자바 함수
프로그래밍 언어에서 **함수**라는 용어는 **메서드(특히 정적 메서드)**와 같은 의미로 사용됩니다.  
자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미합니다.  

**`Java8에서는 함수를 새로운 값의 형식`**으로 추가했습니다.자바 프로그램에서 조작할 수 있는 값을 생각해봅시다.  
1. int형식, double 형식 등의 기본값  
2. 객체. 객체 참조는 클래스의 **인스턴스**를 가리킵니다.  

프로그래밍 언어의 핵심은 값을 바꾸는 것입니다. 이 값을 **일급 값 또는 일급 시민** 이라고 부릅니다.  
구조체(메서드, 클래스 같은) 전달할 수 없는 것들은 이급 시민입니다.  
예를 들어 런타임에 메서드를 전달할 수 있다면, 즉 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있습니다.  
  
따라서 Java8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했습니다.    

### 1.3.1 메서드와 람다를 일급 시민으로
Java8에서 메서드를 값으로 취급할 수 있는 기능은 스트림 같은 다른 Java8 기능의 토대를 제공했습니다.  

**메서드 참조(method reference)**에 대해 알아봅니다.  
  
디렉터리에서 모든 숨겨진 파일을 필터링한다고 가정합니다. File클래스는 이미 isHidden메서드를 제공합니다.
```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
      @Override
      public boolean accept(File file) {
        return file.isHidden();
      }
    });
```
File 클래스에는 이미 isHidden이라는 메서드가 있는데 굳이 FileFilter로 isHidden을 복잡하게 감싼 다음에 FileFilter를 인스턴스화(클래스로부터 객체를 만듦)해야 할까요?  
Java8에서는 다음처럼 구현 가능합니다.  
`File[] hiddenFilesWithMethodReference = new File(".").listFiles(File::isHidden);`  
isHidden이라는 함수는 이미 준비되어 있으므로 메서드 참조를 이용해서 listFiles에 직접 전달할 수 있습니다.  
  
기존에 객체 참조(new로 객체 참조를 생성함)를 이용해서 객체를 주고받았던 것처럼 Java8에서는 `File::isHidden`을 이용해서 메서드 참조를 만들어 전달할 수 있게 되었습니다.  
  
Java8에서는 메서드를 일급값으로 취급할 뿐 아니라 **람다**를 포함하여 함수도 값으로 취급할 수 있습니다.  
람다 문법 형식으로 구현된 프로그램을 **함수형 프로그래밍, 즉 '함수를 일급값으로 넘겨주는 프로그램을 구현한다'**라고 합니다.  

### 1.3.2 코드 넘겨주기 : 예제
모든 녹색 사과를 선택해서 리스트를 반환하는 프로그램은 다음과 같습니다. 이처럼 특정 항목을 선택해서 반환하는 동작을 **필터**라고 합니다.  
Java8 이전의 메서드 구현  
```java
  public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();

    for (Apple apple : inventory) {
      if ("green".equals(apple.getColor())) {
        result.add(apple);
      }
    }
    return result;
  }
```
누군가가 사과를 무게(예를 들어 150그램 이상)으로 필터링하고 싶을 수 있습니다. 그러면 다음처럼 코드를 구현할 수 있습니다.  
```java
 public static List<Apple> filterHeavyApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();

    for (Apple apple : inventory) {
      if (apple.getWeight() > 150) {
        result.add(apple);
      }
    }
    return result;
  }
```
다행히 Java8에서는 코드를 인수로 넘겨줄 수 있으므로 filter 메서드를 중복으로 구현할 필요가 없습니다.  
```java
public static boolean isGreenApple(Apple apple) {
  return "green".equals(apple.getColor()); //녹색 사과 필터링 
}

public static boolean isHeavyApple(Apple apple) {
  return apple.getWeight() > 150; //무거운 사과 필터링
}

public interface Predicate<T> {
  boolean test(T t);
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
  //메서드가 p라는 이름의 프레디케이트 파라미터로 전달됨. 
  List<Apple> result = new ArrayList<>();

  for (Apple apple : inventory) {
    if (p.test(apple)) { //사과는 p가 제시하는 조건에 맞는가?
      result.add(apple); 
    }
  }
  return result;
}  

```  
메서드 호출은 다음처럼 가능합니다.  
```java
filterApples(inventory, Apple::isGreenApple);
filterApples(inventory, Apple::isHeavyApple);
```
수학에서는 인수로 값을 받아 true나 false를 반환하는 함수를 프레디케이트 라고 합니다.  
  
메서드 전달 대신 익명 함수 또는 람다를 이용해서 코드를 구현할 수 있습니다.
```java
filterApples(inventory, (Apple a) -> "green".equals(a.getColor()));
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
filterApples(inventory, (Apple a) -> a.getWeight() < 80 || "red".equals(a.getColor()));
```
람다가 몇 줄 이상으로 길어진다면 익명 람다보다는 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직합니다.  

`filter(inventory, (Apple a) -> a.getWeight() > 150);`와 같이 라이브러리 메서드 filter를 이용하면 filterApples 메서드를 구현할 필요가 없지만,  
`병렬성`이라는 중요성때문에 이와 같은 설계를 포기했습니다.  
  
대신 Java8에서 filter와 비슷한 동작을 수행하는 연산집합을 포함하는 새로운 스트림 API를 제공합니다.  
또한 컬렉션과 스트림 간에 변환할 수 있는 메서드(map, reduce 등)도 제공합니다.  

## 1.4 스트림
컬렉션에서는 반복 과정을 직접 처리해야 했습니다. 즉, for-each 루프를 이용해서 각 요소를 반복하면서 작업을 수행했습니다.이런 방법을 **외부 반복**이라고 합니다.  
반면 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리됩니다. 이와 같은 반복을 **내부 반복**이라고 합니다.  
이론적으로 8개의 코어를 가진 컴퓨터라면 8개 코어를 활용해서 병렬로 작업을 수행하여 단일 CPU 컴퓨터에 비해 8배 빨리 작업을 처리할 수 있습니다.  
  
### 1.4.1 멀티스레딩은 어렵다
멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있습니다.  
결과적으로 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있습니다.  
  
synchronized를 활용하더라도 많은 미묘한 버그가 발생할 수 있습니다.  
Java8에서는 synchronized가 필요치 않은 함수형 프로그래밍 형식의 스트림 기반 병렬성을 이용하도록 권고합니다.  
  
Java8은 스트림 API(java.util.stream)로 `컬렉션을 처리하면서 발생하는 모호함`과 `반복적인 코드 문제` 그리고 `멀티코어 활용 어려움`이라는 문제를 모두 해결했습니다.  
즉, 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 **필터링** 하거나, 데이터를 **추출**하거나, 데이터를 **그룹화**하는 등의 기능이 있습니다.  
또한 이러한 동작들을 쉽게 병렬화할 수 있다는 점도 변화의 동기가 되었습니다.  
  
두 CPU를 가진 환경에서 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을 처리하고, 다른 CPU는 리스트의 뒷부분을 처리하도록 요청할 수 있습니다.  
이 과정을 포킹 단계라고 합니다. 그리고 각각의 CPU는 자신이 맡은 절반의 리스트를 처리합니다. 마지막으로 하나의 CPU가 두 결과를 정리합니다.  

컬렉션은 데이터를 어떻게 저장하고 접근할지에 중점을 두는 반면 스트림은 `데이터에 어떤 계산을 할 것인지 묘사하는 것에` 중점을 둡니다.  
스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다는 것이 핵심입니다.  
  
컬렉션을 필터링할 수 있는 가장 빠른 방법은 다음과 같습니다.  
컬렉션 -> 스트림으로 변환 -> 병렬로 처리 -> 리스트로 다시 복원  
```java
 List<Apple> heavyApples = inventory.stream()
        .filter((Apple a) -> a.getWeight() > 150)
        .collect(toList()); //collect는 Stream의 데이터 변형 등의 처리를 하고 원하는 자료형으로 변환해줍니다.
```
스트림과 람다 표현식을 이용하면 '병렬성을 공짜로'얻을 수 있습니다.  
  
Java8은 라이브러리에서 분할을 처리합니다. 즉, 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할합니다.  
또한 filter 같은 라이브러리 메서드로 전달된 메서드가 상호작용을 하지 않는다면 가변 공유 객체를 통해 공짜로 병렬성을 누릴 수 있습니다.  

함수형 프로그래밍에서 함수형이란 '함수를 일급값으로 사용한다'라는 의미도 있지만 부가적으로  
'프로그램이 실행되는 동안 컴포넌트 간에 상호작용이 일어나지 않는다'라는 의미도 포함합니다.  
  
예전에는 인터페이스를 업데이트하려면 해당 인터페이스를 구현하는 모든 클래스도 업데이트해야 했지만, `디폴트 메서드`로 이 문제를 해결할 수 있습니다.  

## 1.5 디폴트 메서드와 자바 모듈 
Java8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 제공합니다.  
디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아닌, 미래의 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능입니다.  
  
Java8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공합니다.  
메서드 본문(bodies)은 클래스 구현이 아니라 인터페이스의 일부로 포함됩니다.  
  
Java8에서 List에 직접 sort를 호출할 수 있는 이유는 List 인터페이스에 다음과 같은 디폴트 메서드 정의가 추가되었기 때문.  
```java
default void sort(Comparator<? super E> c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator<E> i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }
```
따라서 Java8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 Java8부터는 default sort를 구현하지 않아도 됩니다.  
## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어 
자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어는 다음과 같습니다.  
- 메서드와 람다를 일급 시민(값)으로 사용하는 것  
- 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드를 호출할 수 있다는 것  

## 요약 
- 기존의 자바 프로그래밍 기법으로는 멀티코어 프로세서를 온전히 활용하기 어렵다  
- 함수는 일급값이다.  
- 스트림과 컬렉션을 적절히 활용하면 스트림의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수 있다.  
- 함수형 프로그래밍에서 null 처리 방법(Optional)과 패턴 매칭 활용 등 흥미로운 기법을 발견했다.  
- 디폴트 메서드를 이용해 기존 인터페이스를 구현하는 클래스를 바꾸지 않고도 인터페이스를 변경할 수 있다.  







